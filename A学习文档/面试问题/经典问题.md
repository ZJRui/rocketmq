

问题：如何在同一个JVM进程内创建两个MQClient ，然后连接不同的nameServer，从而实现从MQ集群1接受消息发送到MQ集群2  考察MQ客户端在JVm内如何保持唯一



**instanceName\***

配置说明：客户端实例名称

默认值：从-D系统参数rocketmq.client.name获取，否则就是DEFAULT



这个值虽然默认写是DEFAULT，但在启动的时候，如果我们没有显示修改还是维持其DEFAULT的话，RocketMQ会更新为当前的进程号：

```java
public void changeInstanceNameToPID() {
    if (this.instanceName.equals("DEFAULT")) {
        this.instanceName = String.valueOf(UtilAll.getPid());
    }
}
```

RocketMQ用一个叫ClientID的概念，来唯一标记一个客户端实例，一个客户端实例对于Broker而言会开辟一个Netty的客户端实例。 **而ClientID是由ClientIP+InstanceName构成，故如果一个进程中多个实例（无论Producer还是Consumer）ClientIP和InstanceName都一样,他们将公用一个内部实例（同一套网络连接，线程资源等）**

此外，此ClientID在对于Consumer负载均衡的时候起到唯一标识的作用，一旦多个实例（无论不同进程、不通机器、还是同一进程）的多个Consumer实例有一样的ClientID，负载均衡的时候必然RocketMQ任然会把两个实例当作一个client（因为同样一个clientID）。

故为了避免不必要的问题，ClientIP+instance Name的组合建议唯一，除非有意需要共用连接、资源。



注：如果一个进程内需要连接多个集群（不同NameServer）时候，必须要设置不同的instance name，否则会出现“窜乱”的现象，因为内部管理的时候，一个Client实例只能有一个NameServer的地址，例如：消费者C从自身团队A集群监听消息，然后又作为生产者P发送消息给另外一个团队管理的B集群，这时候新建C和P的时候，必须要显示设置不同的instanceName（建议标识中带上进程号），如下：

```java
consumer.setInstanceName("AConsumer"+UtilAll.getPid());
...
producer.setInstanceName("BProducer"+UtilAll.getPid());
```





问题： MQ是如何实现自动创建topic的

正式环境中会在Broker启动时设置参数autoCreateTopicEnable = false的实现原理



**createTopicKey**



配置说明：发送消息的时候，如果没有找到topic，若想自动创建该topic，需要一个key topic，这个值即是key topic的值。 注意为什么是Broker启动的时候设置 而不是nameSever

默认值：TBW102

这是RocketMQ设计非常晦涩的一个概念，整体的逻辑是这样的：

- 生产者正常的发送消息，都是需要topic预先创建好的
- 但是RocketMQ服务端是支持，发送消息的时候，如果topic不存在，在发送的同时自动创建该topic
- 支持的前提是broker 的配置打开autoCreateTopicEnable=true
- autoCreateTopicEnable=true后，broker会创建一个TBW102的topic，这个就是我们讲的默认的key topic

自动构建topic（以下简称T）的过程：

1. Producer发送的时候如果发现该T不存在，就会向配置有Producer配置的key topic的那个broker发送消息
2. broker校验客户端的topic key是否在broker存在，且校验其权限最后一位是否是1（topic权限总共有3位，按位存储，分别是读、写、支持自动创建）
3. 若权限校验通过，先在该broker把T创建，并且权限就是key topic除去最后一位的权限。
